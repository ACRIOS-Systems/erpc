{% set source = "server" >%}

#include <new>
#include "{$serverCHeaderName}"
#include "{$serverCppHeaderName}"
#include "erpc_manually_constructed.h"

using namespace erpc;
using namespace std;
{% for iface in group.interfaces %}

ERPC_MANUALLY_CONSTRUCTED_STATIC({$iface.serviceClassName}, s_{$iface.serviceClassName});
ERPC_MANUALLY_CONSTRUCTED_STATIC({$iface.serverClassName}, s_{$iface.serverClassName});
{% endfor -- iface %}
{% for iface in group.interfaces %}

class {$iface.serverClassName}: public {$iface.interfaceClassName}
{
    public:
{%  for fn in iface.functions %}
        {$fn.prototype}
        {
            {% if fn.returnValue.type.isNotVoid %}return {% endif%}{$fn.serverPrototypeC}
        }
{%  endfor -- fn %}
};

erpc_service_t create_{$iface.serviceClassName}(void)
{
    erpc_service_t service;

#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
    service = new (nothrow) {$iface.serviceClassName}();
#else
    if (s_{$iface.serviceClassName}.isUsed())
    {
        service = NULL;
    }
    else
    {
        s_{$iface.serviceClassName}.construct();
        service = s_{$iface.serviceClassName}.get();
    }
#endif

    return service;
}

void destroy_{$iface.serviceClassName}(erpc_service_t service)
{
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
    if (service)
    {
        delete ({$iface.serverClassName} *)((({$iface.serviceClassName} *)service)->getHandler());
        delete ({$iface.serviceClassName} *)service;
    }
#else
    (void)service;
    erpc_assert(service == s_{$iface.serviceClassName}.get());
    s_{$iface.serviceClassName}.destroy();
#endif
}

{% endfor -- iface %}
